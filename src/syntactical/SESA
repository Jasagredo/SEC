package syntactical;

import lexical.SELA;
import lexical.SELAErr;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import ast.Dec.*;
import ast.Expr.*;
import ast.Inst.*;
import java.util.List;
import java.util.ArrayList;

scan with {: 
	return getScanner().next_token(); 
:};
parser code {: 
   private SELAErr errores;
   public void syntax_error(ComplexSymbol unidadLexica) {
     errores.errorSintactico(unidadLexica);
   }
:};

init with {: 
   errores = new SELAErr();
   SELA alex = (SELA)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal     CONS,  
			 BLOQUE, FBLOQUE, SEP,
			 PAP, PCI, ASIG, FININSTR,
			 IF, APCON, CICON, ENTONCES, SINO,
			 MIENTRAS, SBUCLE,
			 FSI, FMIENTRAS,
			 APACCESO, CIACCESO, PYC;
terminal Tipo LOG, ENT;
terminal Operadores MAS, MENOS, POR, DIV, IGUAL, MAYOR, MENOR, CON, DIS, NEG;
terminal String ACCESO, IDV, DIM;
terminal String NUMENT;
terminal boolean TRUE, FALSE;

non terminal Block Programa;
non terminal List<Dec> ListaDec;
non terminal List<Inst> ListaInstr;
non terminal Dec Dec;
non terminal Tipo Tipo;
non terminal TipoC TipoC;
non terminal Expr Base;
non terminal NumConst BaseE;
non terminal BoolConst BaseL;
non terminal List<Base> DecArray;
non terminal List<Base> NumPYC;
non terminal Inst Instr;
non terminal Expr Var;
non terminal Operadores OPC;
non terminal Expr Exp;
			  
precedence left IGUAL;
precedence left MENOR, MAYOR;
precedence left MAS, MENOS;
precedence left DIS;
precedence left CON;
precedence left POR, DIV;
precedence left SINO;

start with Programa;

Programa  ::=  BLOQUE ListaDec:ld SEP ListaInstr:li FBLOQUE 	{: RESULT = new Block(ld, li); :}
    ;
ListaDec  ::=  Dec:d ListaDec:ld 								{: ld.add(d); RESULT = ld; :}
	| CONS Dec:d ListaDec:ld									{: d.cons = true; ld.add(d); RESULT = ld; :}
    |															{: RESULT = new ArrayList<Dec>(); :}
    ;
ListaInstr  ::= ListaInstr:li Instr:i							{: li.add(i); RESULT = li; :}
    | 															{: RESULT = new ArrayList<Inst>(); :}
    ;
Dec ::= Tipo:t IDV:i FININSTR 									{: RESULT = new Dec(t, new Id(i), null); :}
	| Tipo:t IDV:i ASIG Base:b FININSTR							{: RESULT = new Dec(t, new Id(i), b); :}
	| TipoC:t IDV:i FININSTR									{: RESULT = new Dec(t, new Id(i), null); :}
	| TipoC:t IDV:i ASIG DecArray:da FININSTR					{: RESULT = new Dec(t, new Id(i), da); :}
    ;
Tipo ::= ENT													{: RESULT = Tipo.ENT; :}
	| LOG														{: RESULT = Tipo.LOG; :}
	;
TipoC ::= TipoC:t DIM:dim											{: t.d.add(Integer.parseInt(dim.substring(1, dim.length()-1))); RESULT = t; :}
	| Tipo:t DIM:d 											{: RESULT = new TipoC(t, d); :}
	;
Base ::= BaseE:b												{: RESULT = b; :}
	| BaseL:l													{: RESULT = l; :}
	| IDV:i														{: RESULT = new Id(i); :}
	;
BaseE ::= NUMENT:n												{: RESULT = new NumConst(n); :}
	;
BaseL ::= TRUE													{: RESULT = new BoolConst(true); :}
	| FALSE														{: RESULT = new BoolConst(false); :}
	;
DecArray ::= APACCESO NumPYC:n CIACCESO							{: RESULT = n; :}
	;
NumPYC ::= NumPYC:n PYC Base:b									{: n.add((Base)b); RESULT = n; :}									
	| Base:b													{: List<Base> np = new ArrayList<Base>(); np.add((Base)b); RESULT = np; :}
	;
Instr ::= FININSTR												{: RESULT = new Vacia(); :}
    | Programa:p												{: RESULT = p; :}
    | Exp:s ASIG Exp:e FININSTR									{: RESULT = new Asig(s,e); :}
    | IF APCON Exp:e CICON ENTONCES ListaInstr:l FSI			{: RESULT = new Ifthen(e, l); :}
    | IF APCON Exp:e CICON ENTONCES ListaInstr:l SINO ListaInstr:m FSI{: RESULT = new IfThenElse(e, l, m); :}
    | MIENTRAS APCON Exp:e CICON SBUCLE ListaInstr:l FMIENTRAS		{: RESULT = new While(e, l); :}
    ;
Var ::= Var:i ACCESO:a											{: RESULT = new Acceso(i, a); :}
	| IDV:i														{: RESULT = new Id(i); :} 
	;
Exp ::= BaseE:b													{: RESULT = b; :}
	| BaseL:l													{: RESULT = l; :}
	| Var:v														{: RESULT = v; :}
    | PAP Exp:e PCI												{: RESULT = e; :}
    | Exp:e1 OPC:o Exp:e2										{: RESULT = new Expr(o, e1, e2); :}
    | NEG Exp:e													{: RESULT = new Expr(Operadores.NEG, null, e); :}
    ;
OPC ::= MAYOR													{: RESULT = Operadores.MAYOR; :}
	| MENOR														{: RESULT = Operadores.MENOR; :}
	| IGUAL														{: RESULT = Operadores.IGUAL; :}
	| CON														{: RESULT = Operadores.CON; :}
	| DIS
	| MAS														{: RESULT = Operadores.MAS; :}
	| MENOS														{: RESULT = Operadores.MENOS; :}
	| POR														{: RESULT = Operadores.POR; :}
	| DIV														{: RESULT = Operadores.DIV; :}
	;